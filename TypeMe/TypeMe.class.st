"
This class stores a list of methods required to extract return types of Pharo Image methods based on various heuristics e.g method's name, method's structure etc.

To run the extraction create a typer instance (TypeMe new) and run the corresponding extract method on it (extract[%package%|%method%|%class%|...]). 
To create a csv file with result run printToCSV on the typer instance.
To see the percentage of methods being typed run statistics method on the typer instance.
 
"
Class {
	#name : 'TypeMe',
	#superclass : 'Object',
	#instVars : [
		'environment',
		'inputMethods',
		'typeResults',
		'conflicts'
	],
	#classInstVars : [
		'typeNameReplacements',
		'typeResults'
	],
	#category : 'TypeMe-Objects',
	#package : 'TypeMe',
	#tag : 'Objects'
}

{ #category : 'as yet unclassified' }
TypeMe class >> getAITypeForClass: className method: methodSelector [

	| typeName |
	typeName := TypeWithAI askOpenAI:
		            'In Pharo programming language what is the type of the method '
		            , methodSelector , ' of the class ' , className
		            ,
		            '. Answer with one word'.

	typeName = 'Unknown'
		ifTrue: [ ^ '' ]
		ifFalse: [ ^ '(type (AI-guess): ' , typeName , ' )' ]
]

{ #category : 'as yet unclassified' }
TypeMe class >> getPrecomputedTypeForClass: className method: methodSelector [
	
	|typeName|
	typeName := (((typeResults at: className ifAbsent: [ ^ '' ])
		              groupedBy: [ :e | e third ])
		             at: methodSelector 
		             ifAbsent: [ ^ '' ]) first fourth.

	^ '(type: ' , typeName , ' )'
]

{ #category : 'as yet unclassified' }
TypeMe class >> getTypeForClass: aClass method: aCompiledMethod [

	| typeName className methodSelector |
	className := aClass name.
	methodSelector := aCompiledMethod selector.

	typeName := self
		            getPrecomputedTypeForClass: className
		            method: methodSelector.
	^ typeName 
	"this is type generated by AI "
	"= ''
		ifTrue: [
		^ self getAITypeForClass: className method: methodSelector ]
		ifFalse: [ ^ typeName ]"
]

{ #category : 'utilities' }
TypeMe class >> replacementFor: aTypeName [

	^ self typeNameReplacements at: aTypeName ifAbsent: [ aTypeName ]
]

{ #category : 'class initialization' }
TypeMe class >> reset [

	<script>
	typeNameReplacements := nil
]

{ #category : 'utilities' }
TypeMe class >> typeNameReplacements [

	^ typeNameReplacements ifNil: [
			  typeNameReplacements := {
				                          (#True -> #Boolean).
				                          (#False -> #Boolean).
				                          (#ByteString -> #String).
				                          (#ByteSymbol -> #String).
				                          (#WideString -> #String).
				                          (#WideSymbol -> #String).
				                          (#BoxedFloat64 -> #Float).
				                          (#SmallFloat64 -> #Float).
				                          (#LargeNegativeInteger -> #Integer).
				                          (#LargePositiveInteger -> #Integer).
				                          (#LargeInteger -> #Integer).
				                          (#SmallInteger -> #Integer) }
				                          asDictionary ]
]

{ #category : 'utilities' }
TypeMe class >> typeResults [

	^ typeResults ifNil: [
		  typeResults := (TITMethodReturnTypesGatherer arraysFromFile:
			                  (FileLocator
				                   fromPath:
				                   'pharo-local/iceberg/lsafina/typeMe/types.csv'
					                   asPath
				                   ifNone: [  ])) groupedBy: [ :e | e second ] ]
]

{ #category : 'analyzing' }
TypeMe >> addToResults: anArray [

	((typeResults at: anArray first ifAbsentPut: Dictionary new)
		 at: anArray second
		 ifAbsentPut: Dictionary new)
		at: anArray third
		ifPresent: [ :existingType |
				existingType = anArray fourth ifFalse: [
					conflicts add: (anArray copyWith: existingType) ] ]
		ifAbsentPut: anArray fourth
]

{ #category : 'analyzing' }
TypeMe >> addToResultsAll: typeCollection [

	| typesToProcess |
	typesToProcess := typeCollection asOrderedCollection.
	[ typesToProcess isNotEmpty ] whileTrue: [
		self addToResults: typesToProcess removeLast ]
]

{ #category : 'aggregating' }
TypeMe >> assertValidName: aName [

	self assert: (aName isKindOf: Symbol).
	self assert: aName isNotEmpty.
	self assert: aName ~= #nil
]

{ #category : 'accessing' }
TypeMe >> environment [

	^ environment ifNil: [ environment := Smalltalk globals ]
]

{ #category : 'extracting' }
TypeMe >> extractTypesForClass: className [

	| classObj collectedMethods |
	collectedMethods := OrderedCollection new.

	classObj := self environment classNamed: className.
	classObj ifNil: [
		self error:
			'Class ' , className , ' is not found in the image. Aborting.' ].

	collectedMethods addAll: classObj methods.
	collectedMethods addAll: classObj class methods.

	self initialize: collectedMethods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForClasses: classNameCollection [

	| collectedMethods |
	collectedMethods := OrderedCollection new.

	classNameCollection do: [ :className |
		| classObj |
		classObj := self environment classNamed: className.
		classObj ifNil: [
			self error:
				'Class ' , className , ' is not found in the image. Aborting.' ].

		collectedMethods addAll: classObj methods.
		collectedMethods addAll: classObj class methods ].

	self initialize: collectedMethods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForImage [

	| collectedMethods |
	collectedMethods := self environment methods.

	self initialize: collectedMethods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForMethod: methodName [

	| collectedMethods |
	collectedMethods := self environment methods select: [ :m |
		                    m selector = methodName ].
	self initialize: collectedMethods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForMethod: aString fromClasses: aCollection [

	| compiledMethods |
	
	compiledMethods := aCollection collect: [ :e |
		                   (self environment at: e asSymbol)
		                   >> aString asSymbol ].
	self initialize: compiledMethods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForMethods: methodNameCollection [

	| collectedMethods |

	collectedMethods := self environment methods select: [ :m |
		                    methodNameCollection includes: m selector ].

	self initialize: collectedMethods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForPackage: packageName [

	self initialize:
		(self environment organization packageNamed: packageName) methods.
	^ self runHeuristics
]

{ #category : 'extracting' }
TypeMe >> extractTypesForPackages: packageNameCollection [

	| collectedMethods |
	collectedMethods := packageNameCollection flatCollect: [ :packageName |
		                    (self environment organization packageNamed: packageName)
			                    methods ].
		
	self initialize: collectedMethods.
	^ self runHeuristics
]

{ #category : 'aggregating' }
TypeMe >> format: aCollection [

	^ aCollection collect: [ :pair |
			  | method |
			  method := pair value.
			  self
				  formatPackage: method package name
				  class: (self getClassName: method)
				  selector: method selector
				  type: pair key ]
]

{ #category : 'aggregating' }
TypeMe >> format: aCollection withType: aType [

	^ aCollection collect: [ :method |
			  self
				  formatPackage: method package name
				  class: (self getClassName: method)
				  selector: method selector
				  type: aType ]
]

{ #category : 'aggregating' }
TypeMe >> formatPackage: aPackageName class: aClassName selector: aSelector type: aTypeName [

	| packageSymbol classSymbol selectorSymbol typeSymbol |
	packageSymbol := aPackageName asSymbol.
	classSymbol := aClassName asSymbol.
	selectorSymbol := aSelector asSymbol.
	typeSymbol := (self replaceTypeName: aTypeName) asSymbol.

	self assertValidName: packageSymbol.
	self assertValidName: classSymbol.
	self assertValidName: selectorSymbol.
	self assertValidName: typeSymbol.

	^ {
		  packageSymbol.
		  classSymbol.
		  selectorSymbol.
		  typeSymbol }
]

{ #category : 'aggregating' }
TypeMe >> formatWithSelf: aMethodCollection [

	^ aMethodCollection collect: [ :method |
			  | className |
			  className := self getClassName: method.
			  self
				  formatPackage: method package name
				  class: className
				  selector: method selector
				  type: className ]
]

{ #category : 'aggregating' }
TypeMe >> getClassName: method [

	^ method methodClass name
]

{ #category : 'instance creation' }
TypeMe >> initialize: methodsCollection [

	inputMethods := methodsCollection.
	typeResults := Dictionary new.
	conflicts := OrderedCollection new
]

{ #category : 'instance creation' }
TypeMe >> initialize: methodsCollection onEnvironment: anEnvironment [

	self initialize: methodsCollection.
	environment := anEnvironment
]

{ #category : 'accessing' }
TypeMe >> inputMethods [

	^ inputMethods
]

{ #category : 'accessing' }
TypeMe >> inputMethods: methodsCollection [

	inputMethods := methodsCollection 
]

{ #category : 'aggregating' }
TypeMe >> methods: methodsSet selectorEqualsString: aString [

	^ methodsSet select: [ :method | method selector = aString ]
]

{ #category : 'aggregating' }
TypeMe >> methods: methodsSet selectorMatchesRegex: aRegex [

	^ methodsSet select: [ :method |
		  aRegex asRegex matches: method selector ]
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnBoolean [
	"collect methods that we expect to return boolean based on their name"

	^ self
		  format: (OrderedCollection new
				   addAll:
					   ({ '^includes[A-Z].*'. '^has[A-Z].*'. '^is[A-Z].*' } flatCollect: [ :aRegex |
							    self
								    methods: inputMethods
								    selectorMatchesRegex: aRegex ]);
				   addAll: ({ 'includes'. '=' } flatCollect: [ :aString |
							    self
								    methods: inputMethods
								    selectorEqualsString: aString ]);
				   yourself)
		  withType: #Boolean
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnClass [
	"collects method that have only one return statement which returns a class (^ %ClassName%)"

	| result |
	result := OrderedCollection new.
	inputMethods do: [ :method |
			ASTHelper
				ifAllReturnsOf: method ast
				satisfy: [ :eachReturn |
				ASTHelper ifReturnReturnsClass: eachReturn ]
				do: [ :return |
						result add:
							(ASTHelper getClassFromReturnNew: return) , ' class' -> method ] ].

	^ self format: result
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnClassNew [
	"collects method that have only one return statement which returns a class new (^ %ClassName% new)"

	| result |
	result := OrderedCollection new.
	inputMethods do: [ :method |
			ASTHelper
				ifAllReturnsOf: method ast
				satisfy: [ :eachReturn |
				ASTHelper ifReturnReturnsClassNew: eachReturn ]
				do: [ :return |
					result add:
						(ASTHelper getClassNameFromReturnNew: return) -> method ] ].

	^ self format: result
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnLiteralNode [
	"collects method that have only one return statement which returns a literal value (^ 5, ^ true, ^ 'BFS' etc)"

	| literalToMethod |
	literalToMethod := OrderedCollection new.

	inputMethods do: [ :method |
			ASTHelper
				ifAllReturnsOf: method ast
				satisfy: [ :eachReturn |
				ASTHelper ifReturnReturnsLiteralNode: eachReturn ]
				do: [ :return |
						literalToMethod add:
							(ASTHelper getReturnLiteralNode: return) className -> method ] ].

	^ self format: literalToMethod
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnNil [
	"collects method that have only one return statement which returns nil (^ nil)"

	^ self
		  format: (inputMethods select: [ :method |
				   ASTHelper ifMethodReturnOnlyNil: method ast ])
		  withType: #UndefinedObject
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnNumber [
	"collect methods that we expect to return Number type subcalsses"

	^ self
		  format: ({ 'size'. 'priority' } flatCollect: [ :aString |
				   self
					   methods: inputMethods
					   selectorEqualsString: aString ])
		  withType: #Number
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnSelf [

	| results |
	results := OrderedCollection new.
	inputMethods do: [ :method |
			method isAbstract ifFalse: [
					ASTHelper
						ifAllReturnsOf: method ast
						satisfy: [ :eachReturn | eachReturn value isSelfVariable ]
						do: [ :return | results add: method ] ] ].
	^ self formatWithSelf: results
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnSelfNew [
	"collects methods that have only one return statement which returns a self new (^ self new)"

	| results |
	results := OrderedCollection new.
	inputMethods do: [ :method |
			method isClassSide ifTrue: [
					ASTHelper
						ifAllReturnsOf: method ast
						satisfy: [ :eachReturn |
						ASTHelper ifReturnReturnsSelfNew: eachReturn ]
						do: [ :return | results add: method ] ] ].
	results ifEmpty: [ ^ {  } ].
	^ self
		  format: results
		  withType: results anyOne methodClass soleInstance name
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnSmallInteger [
	"collect methods that we expect to return SmallInteger"

	^ self
		  format: ({ 'hash' } flatCollect: [ :aString |
				   self methods: inputMethods selectorEqualsString: aString ])
		  withType: #Integer
]

{ #category : 'heuristics' }
TypeMe >> methodsReturnString [
	"collect methods that we expect to return String"

	^ self
		  format:
		  (inputMethods select: [ :method |
			   method selector endsWith: 'String' ])
		  withType: #String
]

{ #category : 'printing' }
TypeMe >> print: typeCollection to: aFormat [

	aFormat = 'csv' ifTrue: [ self printToCSV: typeCollection ]
	
	
]

{ #category : 'printing' }
TypeMe >> printToCSV: aTypeCollection [

	self
		printToCSV: aTypeCollection
		atPath: 'pharo-local/iceberg/typeMe/types.csv'
]

{ #category : 'printing' }
TypeMe >> printToCSV: aTypeCollection atPath: aPath [

	| fileReference |
	fileReference := aPath asFileReference.
	fileReference ensureDelete.
	fileReference writeStreamDo: [ :stream |
			ZnBufferedWriteStream
				on: stream
				do: [ :out |
						| writer |
						writer := NeoCSVWriter on: out.
						writer writeHeader: { #Package. #Class. #Selector. #Types }.
						aTypeCollection do: [ :each | writer nextPut: each ] ] ]
]

{ #category : 'aggregating' }
TypeMe >> replaceTypeName: aTypeName [
	"Replace too specific types like True -> Boolean"

	^ self class replacementFor: aTypeName
]

{ #category : 'run' }
TypeMe >> runHeuristics [

	(self class selectorsInProtocol: 'heuristics') do: [ :method |
			| methodResult |
			methodResult := self perform: method.
			self addToResultsAll: methodResult ].

	conflicts ifNotEmpty: #inspect.
	^ self typeResultArrays
]

{ #category : 'instance creation' }
TypeMe >> setEnvironment: anEnvironment [

	environment := anEnvironment
]

{ #category : 'accessing' }
TypeMe >> statistics [

	^ inputMethods
		  ifNotNil: [
				  Dictionary newFrom: {
						  ('Total amount of methods' -> inputMethods size).
						  ('Amount of methods typed' -> typeResults size).
						  ('% of typed'
						   -> (typeResults size / inputMethods size asFloat * 100
								    printShowingDecimalPlaces: 2)) } ]
		  ifNil: [
		  ^ Warning signal: 'Run type extraction to get statistics' ]
]

{ #category : 'aggregating' }
TypeMe >> typeResultArrays [

	| resultArrays |
	resultArrays := SortedCollection sortBlock: [ :a :b |
			                a first = b first
				                ifTrue: [
						                a second = b second
							                ifTrue: [ a third < b third ]
							                ifFalse: [ a second < b second ] ]
				                ifFalse: [ a first < b first ] ].

	typeResults keysAndValuesDo: [ :packageName :resultsInPackage |
			resultsInPackage keysAndValuesDo: [ :className :resultsInClass |
					resultsInClass keysAndValuesDo: [ :selector :type |
							resultArrays add: {
									packageName.
									className.
									selector.
									type } ] ] ].

	^ resultArrays
]
